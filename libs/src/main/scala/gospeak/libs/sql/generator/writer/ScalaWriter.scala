package gospeak.libs.sql.generator.writer

import gospeak.libs.sql.generator.Database.{Field, Table}
import gospeak.libs.sql.generator.writer.Writer.IdentifierStrategy

class ScalaWriter(directory: String,
                  packageName: String,
                  identifierStrategy: IdentifierStrategy = Writer.IdentifierStrategy.upperCase) extends Writer {
  override protected def rootFolderPath: String = directory + "/" + packageName.replaceAll("\\.", "/")

  override protected def tableFilePath(t: Table): String = tablesFolderPath + "/" + idf(t.name) + ".scala"

  /*
   * Template functions to generate the list of tables
   */

  override protected def listTablesFile(tables: List[Table]): String =
    s"""package $packageName
       |
       |import gospeak.libs.sql.dsl.Table.SqlTable
       |
       |/**
       | * Class generated by ${getClass.getName}
       | */
       |object Tables {
       |${tables.map(listTableAttr).map("  " + _).mkString("\n")}
       |
       |  def getTables: List[SqlTable] = List(${tables.map(t => idf(t.name)).mkString(", ")})
       |}
       |""".stripMargin

  protected def listTableAttr(t: Table): String = s"val ${idf(t.name)}: tables.${idf(t.name)} = tables.${idf(t.name)}.table"

  /*
   * Template functions to generate a Table class
   */

  override protected def tableFile(table: Table): String = {
    val tableName = idf(table.name)
    s"""package $packageName.tables
       |${tableImports(table)}
       |import gospeak.libs.sql.dsl._
       |
       |/**
       | * Class generated by ${getClass.getName}
       | */
       |class $tableName private() extends Table.SqlTable("${table.schema}", "${table.name}", None) {
       |${table.fields.map(tableFieldAttr(table, _)).map("  " + _).mkString("\n")}
       |
       |  override def getFields: List[Field[_, $tableName]] = List(${table.fields.map(f => idf(f.name)).mkString(", ")})${tableAutoJoins(table)}
       |}
       |
       |private[${packageName.split('.').last}] object $tableName {
       |  val table = new $tableName() // unique table instance, should be accessed through `$packageName.Tables` object
       |}
       |""".stripMargin
  }

  protected def tableImports(table: Table): String = {
    val scalaTypes = table.fields.map(scalaType).toSet
    (scalaTypes.contains("Instant"), scalaTypes.contains("LocalDate")) match {
      case (true, true) => "\nimport java.time.{Instant, LocalDate}\n"
      case (true, false) => "\nimport java.time.Instant\n"
      case (false, true) => "\nimport java.time.LocalDate\n"
      case (false, false) => ""
    }
  }

  protected def tableFieldAttr(t: Table, f: Field): String = {
    val (tableName, fieldName, fieldType) = (idf(t.name), idf(f.name), scalaType(f))
    f.ref.map(r => s"""val $fieldName: LinkField[$fieldType, $tableName, ${idf(r.table)}] = new LinkField[$fieldType, $tableName, ${idf(r.table)}](this, "${f.name}", ${idf(r.table)}.table.${idf(r.field)}) // ${f.`type`}""")
      .getOrElse(s"""val $fieldName: Field[$fieldType, $tableName] = new Field[$fieldType, $tableName](this, "${f.name}") // ${f.`type`}""")
  }

  protected def tableAutoJoins(table: Table): String =
    table.fields.filter(_.ref.isDefined)
      .map(f => s"\n\n  def ${idf(f.name)}Join: Table.JoinTable = join(${idf(f.ref.get.table)}.table, ${idf(f.name)}.is(${idf(f.ref.get.table)}.table.${idf(f.ref.get.field)}))")
      .mkString

  /*
   * Utils functions
   */

  protected def idf(value: String): String = identifierStrategy.format(value)

  protected def scalaType(f: Field): String = f.kind match {
    case "BIGINT" => "Long"
    case "BOOLEAN" => "Boolean"
    case "DATE" => "LocalDate"
    case "DOUBLE" => "Double"
    case "INTEGER" => "Int"
    case "SMALLINT" => "Short"
    case "TIMESTAMP" | "TIMESTAMP WITH TIME ZONE" => "Instant"
    case "VARCHAR" | "CHAR" => "String"
  }
}
