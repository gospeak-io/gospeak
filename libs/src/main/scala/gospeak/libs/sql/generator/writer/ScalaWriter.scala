package gospeak.libs.sql.generator.writer

import gospeak.libs.sql.generator.Database.{Field, FieldRef, Table}
import gospeak.libs.sql.generator.writer.ScalaWriter.DatabaseConfig
import gospeak.libs.sql.generator.writer.Writer.IdentifierStrategy

class ScalaWriter(directory: String,
                  packageName: String,
                  identifierStrategy: IdentifierStrategy = Writer.IdentifierStrategy.upperCase,
                  config: DatabaseConfig) extends Writer {
  override protected def rootFolderPath: String = directory + "/" + packageName.replaceAll("\\.", "/")

  override protected def tableFilePath(t: Table): String = tablesFolderPath + "/" + idf(t.name) + ".scala"

  /*
   * Template functions to generate the list of tables
   */

  override protected def listTablesFile(tables: List[Table]): String =
    s"""package $packageName
       |
       |import gospeak.libs.sql.dsl.Table.SqlTable
       |
       |/**
       | * Class generated by ${getClass.getName}
       | */
       |object Tables {
       |${tables.map(listTableAttr).map("  " + _).mkString("\n")}
       |
       |  def getTables: List[SqlTable] = List(${tables.map(t => idf(t.name)).mkString(", ")})
       |}
       |""".stripMargin

  protected def listTableAttr(t: Table): String = s"val ${idf(t.name)}: tables.${idf(t.name)} = tables.${idf(t.name)}.table"

  /*
   * Template functions to generate a Table class
   */

  override protected def tableFile(table: Table): String = {
    val tableName = idf(table.name)
    val alias = config.table(table).alias.map(a => s"""Some("$a")""").getOrElse("None")
    s"""package $packageName.tables
       |${tableImports(table)}
       |import gospeak.libs.sql.dsl._
       |
       |/**
       | * Class generated by ${getClass.getName}
       | */
       |class $tableName private() extends Table.SqlTable("${table.schema}", "${table.name}", $alias) {
       |${table.fields.map(tableFieldAttr(table, _)).map("  " + _).mkString("\n")}
       |
       |  override def getFields: List[Field[_, $tableName]] = List(${table.fields.map(f => idf(f.name)).mkString(", ")})${tableAutoJoins(table)}
       |}
       |
       |private[${packageName.split('.').last}] object $tableName {
       |  val table = new $tableName() // unique table instance, should be accessed through `$packageName.Tables` object
       |}
       |""".stripMargin
  }

  protected def tableImports(table: Table): String = {
    val scalaTypes = table.fields.map(scalaType).toSet
    (scalaTypes.contains("Instant"), scalaTypes.contains("LocalDate")) match {
      case (true, true) => "\nimport java.time.{Instant, LocalDate}\n"
      case (true, false) => "\nimport java.time.Instant\n"
      case (false, true) => "\nimport java.time.LocalDate\n"
      case (false, false) => ""
    }
  }

  protected def tableFieldAttr(t: Table, f: Field): String = {
    val (tableName, fieldName) = (idf(t.name), idf(f.name))
    val fieldType = f.ref.filter(_ => config.customTypesFollowReferences).flatMap(config.field(_).customType)
      .orElse(config.field(f).customType)
      .getOrElse(scalaType(f))
    // TODO val fieldType = if (f.nullable) s"Option[$fieldKind]" else fieldKind // not possible yet because of FieldRef that require same type (I don't know to to link to A or Option[A]...)
    f.ref.map(r => s"""val $fieldName: FieldRef[$fieldType, $tableName, ${idf(r.table)}] = new FieldRef[$fieldType, $tableName, ${idf(r.table)}](this, "${f.name}", ${idf(r.table)}.table.${idf(r.field)}) // ${f.`type`}""")
      .getOrElse(s"""val $fieldName: Field[$fieldType, $tableName] = new Field[$fieldType, $tableName](this, "${f.name}") // ${f.`type`}""")
  }

  protected def tableAutoJoins(table: Table): String =
    table.fields.filter(_.ref.isDefined)
      .map(f => s"\n\n  def ${idf(f.name)}Join: Table.JoinTable = join(${idf(f.ref.get.table)}.table).on(_.${idf(f.name)} eq _.${idf(f.ref.get.field)})")
      .mkString

  /*
   * Utils functions
   */

  protected def idf(value: String): String = identifierStrategy.format(value)

  protected def scalaType(f: Field): String = f.kind match {
    case "BIGINT" => "Long"
    case "BOOLEAN" => "Boolean"
    case "DATE" => "LocalDate"
    case "DOUBLE" => "Double"
    case "INTEGER" => "Int"
    case "SMALLINT" => "Short"
    case "TIMESTAMP" | "TIMESTAMP WITH TIME ZONE" => "Instant"
    case "VARCHAR" | "CHAR" => "String"
  }
}

object ScalaWriter {

  case class DatabaseConfig(customTypesFollowReferences: Boolean = true, // if a field has a reference to an other field having a custom type, it inherit from the custom type
                            schemas: Map[String, SchemaConfig] = Map()) {
    def schema(name: String): SchemaConfig = schemas.getOrElse(name, SchemaConfig())

    def table(schema: String, table: String): TableConfig = this.schema(schema).tables.getOrElse(table, TableConfig())

    def table(table: Table): TableConfig = this.table(table.schema, table.name)

    def field(schema: String, table: String, field: String): FieldConfig = this.table(schema, table).fields.getOrElse(field, FieldConfig())

    def field(table: Table, field: String): FieldConfig = this.field(table.schema, table.name, field)

    def field(field: Field): FieldConfig = this.field(field.schema, field.table, field.name)

    def field(field: FieldRef): FieldConfig = this.field(field.schema, field.table, field.field)
  }

  case class SchemaConfig(tables: Map[String, TableConfig] = Map())

  case class TableConfig(alias: Option[String] = None, fields: Map[String, FieldConfig] = Map())

  case class FieldConfig(customType: Option[String] = None) // override the computed type with this one, should be the fully qualified name

}
